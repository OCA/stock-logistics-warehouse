# Copyright 2024 Akretion (http://www.akretion.com).
# @author Florian Mounier <florian.mounier@akretion.com>
# License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl).

from odoo import _, api, fields, models
from odoo.exceptions import UserError


class StockWarehouseOrderpointTemplate(models.Model):
    """Defines Templates for Minimum stock rules."""

    _name = "stock.warehouse.orderpoint.template"
    _description = "Minimum Inventory Rule Template"
    _check_company_auto = True
    _order = "location_id,company_id,id"

    @api.model
    def default_get(self, fields):
        res = super().default_get(fields)
        warehouse = None
        if "warehouse_id" not in res and res.get("company_id"):
            warehouse = self.env["stock.warehouse"].search(
                [("company_id", "=", res["company_id"])], limit=1
            )
        if warehouse:
            res["warehouse_id"] = warehouse.id
        return res

    name = fields.Char("Reference", default="/", copy=False, index=True, readonly=True)

    warehouse_id = fields.Many2one(
        "stock.warehouse",
        "Warehouse",
        check_company=True,
        ondelete="cascade",
        required=True,
    )
    location_id = fields.Many2one(
        "stock.location",
        "Location",
        index=True,
        ondelete="cascade",
        required=True,
        check_company=True,
    )

    product_min_qty = fields.Float(
        "Min Quantity",
        digits="Product Unit of Measure",
        required=True,
        default=0.0,
        help="When the virtual stock equals to or goes below the Min Quantity "
        "specified for this field, Odoo generates a procurement to bring the "
        "forecasted quantity to the Max Quantity.",
    )
    product_max_qty = fields.Float(
        "Max Quantity",
        digits="Product Unit of Measure",
        required=True,
        default=0.0,
        help="When the virtual stock goes below the Min Quantity, Odoo generates "
        "a procurement to bring the forecasted quantity to the Quantity "
        "specified as Max Quantity.",
    )
    qty_multiple = fields.Float(
        "Multiple Quantity",
        digits="Product Unit of Measure",
        default=1,
        required=True,
        help="The procurement quantity will be rounded up to this multiple. "
        "If it is 0, the exact quantity will be used.",
    )

    group_id = fields.Many2one(
        "procurement.group",
        "Procurement Group",
        copy=False,
        help="Moves created through this orderpoint will be put in this "
        "procurement group. If none is given, the moves generated by stock "
        "rules will be grouped into one big picking.",
    )
    company_id = fields.Many2one(
        "res.company",
        "Company",
        required=True,
        index=True,
        default=lambda self: self.env.company,
    )

    allowed_location_ids = fields.One2many(
        comodel_name="stock.location", compute="_compute_allowed_location_ids"
    )

    orderpoint_ids = fields.One2many(
        "stock.warehouse.orderpoint",
        "template_id",
        "Orderpoints",
        check_company=True,
    )

    orderpoints_count = fields.Integer(
        "Orderpoints Count", compute="_compute_orderpoint_count"
    )

    # We need to have only one template per location
    _sql_constraints = [
        (
            "location_uniq",
            "unique (location_id)",
            "Only one template per location is allowed.",
        )
    ]

    @api.depends("warehouse_id")
    def _compute_allowed_location_ids(self):
        # Use same method as stock.warehouse.orderpoint
        self.env["stock.warehouse.orderpoint"].__class__._compute_allowed_location_ids(
            self
        )
        # Then remove existing template locations
        domain = [("warehouse_id", "=", self.warehouse_id.id)]
        if not isinstance(self.id, models.NewId):
            # Keep current template location
            domain.append(("id", "!=", self.id))

        existing_location_ids = self.search(domain).mapped("location_id")

        for template in self:
            template.allowed_location_ids = (
                template.allowed_location_ids - existing_location_ids
            )

    @api.depends("orderpoint_ids")
    def _compute_orderpoint_count(self):
        data = self.env["stock.warehouse.orderpoint"].read_group(
            [("template_id", "in", self.ids)],
            ["template_id"],
            ["template_id"],
        )
        mapped_data = {
            record["template_id"][0]: record["template_id_count"] for record in data
        }
        for template in self:
            template.orderpoints_count = mapped_data.get(template.id, 0)

    @api.onchange("location_id")
    def _onchange_location_id(self):
        warehouse = self.location_id.get_warehouse().id
        if warehouse:
            self.warehouse_id = warehouse

    @api.onchange("warehouse_id")
    def _onchange_warehouse_id(self):
        """Finds location id for changed warehouse."""
        if (
            self.warehouse_id
            and self.warehouse_id.lot_stock_id in self.allowed_location_ids
        ):
            self.location_id = self.warehouse_id.lot_stock_id.id
        else:
            self.location_id = False

    @api.onchange("company_id")
    def _onchange_company_id(self):
        if self.company_id:
            self.warehouse_id = self.env["stock.warehouse"].search(
                [("company_id", "=", self.company_id.id)], limit=1
            )

    def write(self, vals):
        if "company_id" in vals:
            for template in self:
                if template.company_id.id != vals["company_id"]:
                    raise UserError(
                        _(
                            "Changing the company of this record is forbidden "
                            "at this point, you should rather archive it and "
                            "create a new one."
                        )
                    )
        # Update child orderpoints
        self.orderpoint_ids.write(
            {
                key: value
                for key, value in vals.items()
                if key in self._get_propagate_fields()
            }
        )

        return super().write(vals)

    def _get_propagate_fields(self):
        return [
            "location_id",
            "product_min_qty",
            "product_max_qty",
            "qty_multiple",
            "warehouse_id",
            "company_id",
            "group_id",
        ]

    @api.model
    def create(self, vals):
        if vals.get("name", "/") == "/":
            vals["name"] = self.env["ir.sequence"].next_by_code(
                "stock.orderpoint.template",
            )
        return super().create(vals)

    def _prepare_orderpoint_vals(self, product):
        self.ensure_one()
        return {
            "product_id": product.id,
            "location_id": self.location_id.id,
            "product_min_qty": self.product_min_qty,
            "product_max_qty": self.product_max_qty,
            "qty_multiple": self.qty_multiple,
            "warehouse_id": self.warehouse_id.id,
            "company_id": self.company_id.id,
            "group_id": self.group_id.id,
            "template_id": self.id,
            "trigger": "auto",
        }

    def _create_orderpoint(self, product):
        self.ensure_one()
        return self.env["stock.warehouse.orderpoint"].create(
            self._prepare_orderpoint_vals(product)
        )
